import { Inject, Injectable } from '@angular/core';
import { AsyncSubject, isObservable, ReplaySubject } from 'rxjs';
import { GoogleLoginProvider } from './providers/google-login-provider';
import * as i0 from "@angular/core";
/**
 * The service encapsulating the social login functionality. Exposes methods like
 * `signIn`, `signOut`. Also, exposes an `authState` `Observable` that one can
 * subscribe to get the current logged in user information.
 *
 * @dynamic
 */
class SocialAuthService {
    static { this.ERR_LOGIN_PROVIDER_NOT_FOUND = 'Login provider not found'; }
    static { this.ERR_NOT_LOGGED_IN = 'Not logged in'; }
    static { this.ERR_NOT_INITIALIZED = 'Login providers not ready yet. Are there errors on your console?'; }
    static { this.ERR_NOT_SUPPORTED_FOR_REFRESH_TOKEN = 'Chosen login provider is not supported for refreshing a token'; }
    static { this.ERR_NOT_SUPPORTED_FOR_ACCESS_TOKEN = 'Chosen login provider is not supported for getting an access token'; }
    /** An `Observable` that one can subscribe to get the current logged in user information */
    get authState() {
        return this._authState.asObservable();
    }
    /** An `Observable` to communicate the readiness of the service and associated login providers */
    get initState() {
        return this._initState.asObservable();
    }
    /**
     * @param config A `SocialAuthServiceConfig` object or a `Promise` that resolves to a `SocialAuthServiceConfig` object
     */
    constructor(config, _ngZone, _injector) {
        this._ngZone = _ngZone;
        this._injector = _injector;
        this.providers = new Map();
        this.autoLogin = false;
        this._user = null;
        this._authState = new ReplaySubject(1);
        /* Consider making this an enum comprising LOADING, LOADED, FAILED etc. */
        this.initialized = false;
        this._initState = new AsyncSubject();
        if (config instanceof Promise) {
            config.then((config) => {
                this.initialize(config);
            });
        }
        else {
            this.initialize(config);
        }
    }
    initialize(config) {
        this.autoLogin = config.autoLogin !== undefined ? config.autoLogin : false;
        const { onError = console.error } = config;
        config.providers.forEach((item) => {
            this.providers.set(item.id, 'prototype' in item.provider
                ? this._injector.get(item.provider)
                : item.provider);
        });
        Promise.all(Array.from(this.providers.values()).map((provider) => provider.initialize(this.autoLogin)))
            .then(() => {
            if (this.autoLogin) {
                const loginStatusPromises = [];
                let loggedIn = false;
                this.providers.forEach((provider, key) => {
                    const promise = provider.getLoginStatus();
                    loginStatusPromises.push(promise);
                    promise
                        .then((user) => {
                        this.setUser(user, key);
                        loggedIn = true;
                    })
                        .catch(console.debug);
                });
                Promise.all(loginStatusPromises).catch(() => {
                    if (!loggedIn) {
                        this._user = null;
                        this._authState.next(null);
                    }
                });
            }
            this.providers.forEach((provider, key) => {
                if (isObservable(provider.changeUser)) {
                    provider.changeUser.subscribe((user) => {
                        this._ngZone.run(() => {
                            this.setUser(user, key);
                        });
                    });
                }
            });
        })
            .catch((error) => {
            onError(error);
        })
            .finally(() => {
            this.initialized = true;
            this._initState.next(this.initialized);
            this._initState.complete();
        });
    }
    async getAccessToken(providerId) {
        const providerObject = this.providers.get(providerId);
        if (!this.initialized) {
            throw SocialAuthService.ERR_NOT_INITIALIZED;
        }
        else if (!providerObject) {
            throw SocialAuthService.ERR_LOGIN_PROVIDER_NOT_FOUND;
        }
        else if (!(providerObject instanceof GoogleLoginProvider)) {
            throw SocialAuthService.ERR_NOT_SUPPORTED_FOR_ACCESS_TOKEN;
        }
        return await providerObject.getAccessToken();
    }
    refreshAuthToken(providerId) {
        return new Promise((resolve, reject) => {
            if (!this.initialized) {
                reject(SocialAuthService.ERR_NOT_INITIALIZED);
            }
            else {
                const providerObject = this.providers.get(providerId);
                if (providerObject) {
                    if (typeof providerObject.refreshToken !== 'function') {
                        reject(SocialAuthService.ERR_NOT_SUPPORTED_FOR_REFRESH_TOKEN);
                    }
                    else {
                        providerObject
                            .refreshToken()
                            .then((user) => {
                            this.setUser(user, providerId);
                            resolve();
                        })
                            .catch((err) => {
                            reject(err);
                        });
                    }
                }
                else {
                    reject(SocialAuthService.ERR_LOGIN_PROVIDER_NOT_FOUND);
                }
            }
        });
    }
    refreshAccessToken(providerId) {
        return new Promise((resolve, reject) => {
            if (!this.initialized) {
                reject(SocialAuthService.ERR_NOT_INITIALIZED);
            }
            else if (providerId !== GoogleLoginProvider.PROVIDER_ID) {
                reject(SocialAuthService.ERR_NOT_SUPPORTED_FOR_REFRESH_TOKEN);
            }
            else {
                const providerObject = this.providers.get(providerId);
                if (providerObject instanceof GoogleLoginProvider) {
                    providerObject.revokeAccessToken().then(resolve).catch(reject);
                }
                else {
                    reject(SocialAuthService.ERR_LOGIN_PROVIDER_NOT_FOUND);
                }
            }
        });
    }
    /**
     * A method used to sign in a user with a specific `LoginProvider`.
     *
     * @param providerId Id with which the `LoginProvider` has been registered with the service
     * @param signInOptions Optional `LoginProvider` specific arguments
     * @returns A `Promise` that resolves to the authenticated user information
     */
    signIn(providerId, signInOptions) {
        return new Promise((resolve, reject) => {
            if (!this.initialized) {
                reject(SocialAuthService.ERR_NOT_INITIALIZED);
            }
            else {
                let providerObject = this.providers.get(providerId);
                if (providerObject) {
                    providerObject
                        .signIn(signInOptions)
                        .then((user) => {
                        this.setUser(user, providerId);
                        resolve(user);
                    })
                        .catch((err) => {
                        reject(err);
                    });
                }
                else {
                    reject(SocialAuthService.ERR_LOGIN_PROVIDER_NOT_FOUND);
                }
            }
        });
    }
    /**
     * A method used to sign out the currently loggen in user.
     *
     * @param revoke Optional parameter to specify whether a hard sign out is to be performed
     * @returns A `Promise` that resolves if the operation is successful, rejects otherwise
     */
    signOut(revoke = false) {
        return new Promise((resolve, reject) => {
            if (!this.initialized) {
                reject(SocialAuthService.ERR_NOT_INITIALIZED);
            }
            else if (!this._user) {
                reject(SocialAuthService.ERR_NOT_LOGGED_IN);
            }
            else {
                let providerId = this._user.provider;
                let providerObject = this.providers.get(providerId);
                if (providerObject) {
                    providerObject
                        .signOut(revoke)
                        .then(() => {
                        resolve();
                        this.setUser(null);
                    })
                        .catch((err) => {
                        reject(err);
                    });
                }
                else {
                    reject(SocialAuthService.ERR_LOGIN_PROVIDER_NOT_FOUND);
                }
            }
        });
    }
    setUser(user, id) {
        if (user && id)
            user.provider = id;
        this._user = user;
        this._authState.next(user);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.0.0", ngImport: i0, type: SocialAuthService, deps: [{ token: 'SocialAuthServiceConfig' }, { token: i0.NgZone }, { token: i0.Injector }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.0.0", ngImport: i0, type: SocialAuthService, providedIn: 'root' }); }
}
export { SocialAuthService };
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.0.0", ngImport: i0, type: SocialAuthService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: ['SocialAuthServiceConfig']
                }] }, { type: i0.NgZone }, { type: i0.Injector }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic29jaWFsYXV0aC5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vcHJvamVjdHMvbGliL3NyYy9zb2NpYWxhdXRoLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLE1BQU0sRUFBRSxVQUFVLEVBQTBCLE1BQU0sZUFBZSxDQUFDO0FBQzNFLE9BQU8sRUFBRSxZQUFZLEVBQUUsWUFBWSxFQUFjLGFBQWEsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUc3RSxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSxtQ0FBbUMsQ0FBQzs7QUFXeEU7Ozs7OztHQU1HO0FBQ0gsTUFDYSxpQkFBaUI7YUFDSixpQ0FBNEIsR0FDbEQsMEJBQTBCLEFBRHdCLENBQ3ZCO2FBQ0wsc0JBQWlCLEdBQUcsZUFBZSxBQUFsQixDQUFtQjthQUNwQyx3QkFBbUIsR0FDekMsa0VBQWtFLEFBRHpCLENBQzBCO2FBQzdDLHdDQUFtQyxHQUN6RCwrREFBK0QsQUFETixDQUNPO2FBQzFDLHVDQUFrQyxHQUN4RCxvRUFBb0UsQUFEWixDQUNhO0lBWXZFLDJGQUEyRjtJQUMzRixJQUFJLFNBQVM7UUFDWCxPQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsWUFBWSxFQUFFLENBQUM7SUFDeEMsQ0FBQztJQUVELGlHQUFpRztJQUNqRyxJQUFJLFNBQVM7UUFDWCxPQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsWUFBWSxFQUFFLENBQUM7SUFDeEMsQ0FBQztJQUVEOztPQUVHO0lBQ0gsWUFFRSxNQUFrRSxFQUNqRCxPQUFlLEVBQ2YsU0FBbUI7UUFEbkIsWUFBTyxHQUFQLE9BQU8sQ0FBUTtRQUNmLGNBQVMsR0FBVCxTQUFTLENBQVU7UUEzQjlCLGNBQVMsR0FBK0IsSUFBSSxHQUFHLEVBQUUsQ0FBQztRQUNsRCxjQUFTLEdBQUcsS0FBSyxDQUFDO1FBRWxCLFVBQUssR0FBc0IsSUFBSSxDQUFDO1FBQ2hDLGVBQVUsR0FBcUMsSUFBSSxh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SUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUM7UUFDbEIsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDN0IsQ0FBQzs4R0F6T1UsaUJBQWlCLGtCQW1DbEIseUJBQXlCO2tIQW5DeEIsaUJBQWlCLGNBREosTUFBTTs7U0FDbkIsaUJBQWlCOzJGQUFqQixpQkFBaUI7a0JBRDdCLFVBQVU7bUJBQUMsRUFBRSxVQUFVLEVBQUUsTUFBTSxFQUFFOzswQkFvQzdCLE1BQU07MkJBQUMseUJBQXlCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0LCBJbmplY3RhYmxlLCBJbmplY3RvciwgTmdab25lLCBUeXBlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IEFzeW5jU3ViamVjdCwgaXNPYnNlcnZhYmxlLCBPYnNlcnZhYmxlLCBSZXBsYXlTdWJqZWN0IH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IExvZ2luUHJvdmlkZXIgfSBmcm9tICcuL2VudGl0aWVzL2xvZ2luLXByb3ZpZGVyJztcclxuaW1wb3J0IHsgU29jaWFsVXNlciB9IGZyb20gJy4vZW50aXRpZXMvc29jaWFsLXVzZXInO1xyXG5pbXBvcnQgeyBHb29nbGVMb2dpblByb3ZpZGVyIH0gZnJvbSAnLi9wcm92aWRlcnMvZ29vZ2xlLWxvZ2luLXByb3ZpZGVyJztcclxuXHJcbi8qKlxyXG4gKiBBbiBpbnRlcmZhY2UgdG8gZGVmaW5lIHRoZSBzaGFwZSBvZiB0aGUgc2VydmljZSBjb25maWd1cmF0aW9uIG9wdGlvbnMuXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIFNvY2lhbEF1dGhTZXJ2aWNlQ29uZmlnIHtcclxuICBhdXRvTG9naW4/OiBib29sZWFuO1xyXG4gIHByb3ZpZGVyczogeyBpZDogc3RyaW5nOyBwcm92aWRlcjogTG9naW5Qcm92aWRlciB8IFR5cGU8TG9naW5Qcm92aWRlcj4gfVtdO1xyXG4gIG9uRXJyb3I/OiAoZXJyb3I6IGFueSkgPT4gYW55O1xyXG59XHJcblxyXG4vKipcclxuICogVGhlIHNlcnZpY2UgZW5jYXBzdWxhdGluZyB0aGUgc29jaWFsIGxvZ2luIGZ1bmN0aW9uYWxpdHkuIEV4cG9zZXMgbWV0aG9kcyBsaWtlXHJcbiAqIGBzaWduSW5gLCBgc2lnbk91dGAuIEFsc28sIGV4cG9zZXMgYW4gYGF1dGhTdGF0ZWAgYE9ic2VydmFibGVgIHRoYXQgb25lIGNhblxyXG4gKiBzdWJzY3JpYmUgdG8gZ2V0IHRoZSBjdXJyZW50IGxvZ2dlZCBpbiB1c2VyIGluZm9ybWF0aW9uLlxyXG4gKlxyXG4gKiBAZHluYW1pY1xyXG4gKi9cclxuQEluamVjdGFibGUoeyBwcm92aWRlZEluOiAncm9vdCcgfSlcclxuZXhwb3J0IGNsYXNzIFNvY2lhbEF1dGhTZXJ2aWNlIHtcclxuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBFUlJfTE9HSU5fUFJPVklERVJfTk9UX0ZPVU5EID1cclxuICAgICdMb2dpbiBwcm92aWRlciBub3QgZm91bmQnO1xyXG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IEVSUl9OT1RfTE9HR0VEX0lOID0gJ05vdCBsb2dnZWQgaW4nO1xyXG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IEVSUl9OT1RfSU5JVElBTElaRUQgPVxyXG4gICAgJ0xvZ2luIHByb3ZpZGVycyBub3QgcmVhZHkgeWV0LiBBcmUgdGhlcmUgZXJyb3JzIG9uIHlvdXIgY29uc29sZT8nO1xyXG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IEVSUl9OT1RfU1VQUE9SVEVEX0ZPUl9SRUZSRVNIX1RPS0VOID1cclxuICAgICdDaG9zZW4gbG9naW4gcHJvdmlkZXIgaXMgbm90IHN1cHBvcnRlZCBmb3IgcmVmcmVzaGluZyBhIHRva2VuJztcclxuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBFUlJfTk9UX1NVUFBPUlRFRF9GT1JfQUNDRVNTX1RPS0VOID1cclxuICAgICdDaG9zZW4gbG9naW4gcHJvdmlkZXIgaXMgbm90IHN1cHBvcnRlZCBmb3IgZ2V0dGluZyBhbiBhY2Nlc3MgdG9rZW4nO1xyXG5cclxuICBwcml2YXRlIHByb3ZpZGVyczogTWFwPHN0cmluZywgTG9naW5Qcm92aWRlcj4gPSBuZXcgTWFwKCk7XHJcbiAgcHJpdmF0ZSBhdXRvTG9naW4gPSBmYWxzZTtcclxuXHJcbiAgcHJpdmF0ZSBfdXNlcjogU29jaWFsVXNlciB8IG51bGwgPSBudWxsO1xyXG4gIHByaXZhdGUgX2F1dGhTdGF0ZTogUmVwbGF5U3ViamVjdDxTb2NpYWxVc2VyIHwgbnVsbD4gPSBuZXcgUmVwbGF5U3ViamVjdCgxKTtcclxuXHJcbiAgLyogQ29uc2lkZXIgbWFraW5nIHRoaXMgYW4gZW51bSBjb21wcmlzaW5nIExPQURJTkcsIExPQURFRCwgRkFJTEVEIGV0Yy4gKi9cclxuICBwcml2YXRlIGluaXRpYWxpemVkID0gZmFsc2U7XHJcbiAgcHJpdmF0ZSBfaW5pdFN0YXRlOiBBc3luY1N1YmplY3Q8Ym9vbGVhbj4gPSBuZXcgQXN5bmNTdWJqZWN0KCk7XHJcblxyXG4gIC8qKiBBbiBgT2JzZXJ2YWJsZWAgdGhhdCBvbmUgY2FuIHN1YnNjcmliZSB0byBnZXQgdGhlIGN1cnJlbnQgbG9nZ2VkIGluIHVzZXIgaW5mb3JtYXRpb24gKi9cclxuICBnZXQgYXV0aFN0YXRlKCk6IE9ic2VydmFibGU8U29jaWFsVXNlcj4ge1xyXG4gICAgcmV0dXJuIHRoaXMuX2F1dGhTdGF0ZS5hc09ic2VydmFibGUoKTtcclxuICB9XHJcblxyXG4gIC8qKiBBbiBgT2JzZXJ2YWJsZWAgdG8gY29tbXVuaWNhdGUgdGhlIHJlYWRpbmVzcyBvZiB0aGUgc2VydmljZSBhbmQgYXNzb2NpYXRlZCBsb2dpbiBwcm92aWRlcnMgKi9cclxuICBnZXQgaW5pdFN0YXRlKCk6IE9ic2VydmFibGU8Ym9vbGVhbj4ge1xyXG4gICAgcmV0dXJuIHRoaXMuX2luaXRTdGF0ZS5hc09ic2VydmFibGUoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSBjb25maWcgQSBgU29jaWFsQXV0aFNlcnZpY2VDb25maWdgIG9iamVjdCBvciBhIGBQcm9taXNlYCB0aGF0IHJlc29sdmVzIHRvIGEgYFNvY2lhbEF1dGhTZXJ2aWNlQ29uZmlnYCBvYmplY3RcclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihcclxuICAgIEBJbmplY3QoJ1NvY2lhbEF1dGhTZXJ2aWNlQ29uZmlnJylcclxuICAgIGNvbmZpZzogU29jaWFsQXV0aFNlcnZpY2VDb25maWcgfCBQcm9taXNlPFNvY2lhbEF1dGhTZXJ2aWNlQ29uZmlnPixcclxuICAgIHByaXZhdGUgcmVhZG9ubHkgX25nWm9uZTogTmdab25lLFxyXG4gICAgcHJpdmF0ZSByZWFkb25seSBfaW5qZWN0b3I6IEluamVjdG9yXHJcbiAgKSB7XHJcbiAgICBpZiAoY29uZmlnIGluc3RhbmNlb2YgUHJvbWlzZSkge1xyXG4gICAgICBjb25maWcudGhlbigoY29uZmlnOiBTb2NpYWxBdXRoU2VydmljZUNvbmZpZykgPT4ge1xyXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZShjb25maWcpO1xyXG4gICAgICB9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZShjb25maWcpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBpbml0aWFsaXplKGNvbmZpZzogU29jaWFsQXV0aFNlcnZpY2VDb25maWcpIHtcclxuICAgIHRoaXMuYXV0b0xvZ2luID0gY29uZmlnLmF1dG9Mb2dpbiAhPT0gdW5kZWZpbmVkID8gY29uZmlnLmF1dG9Mb2dpbiA6IGZhbHNlO1xyXG4gICAgY29uc3QgeyBvbkVycm9yID0gY29uc29sZS5lcnJvciB9ID0gY29uZmlnO1xyXG5cclxuICAgIGNvbmZpZy5wcm92aWRlcnMuZm9yRWFjaCgoaXRlbSkgPT4ge1xyXG4gICAgICB0aGlzLnByb3ZpZGVycy5zZXQoXHJcbiAgICAgICAgaXRlbS5pZCxcclxuICAgICAgICAncHJvdG90eXBlJyBpbiBpdGVtLnByb3ZpZGVyXHJcbiAgICAgICAgICA/IHRoaXMuX2luamVjdG9yLmdldChpdGVtLnByb3ZpZGVyKVxyXG4gICAgICAgICAgOiBpdGVtLnByb3ZpZGVyXHJcbiAgICAgICk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBQcm9taXNlLmFsbChcclxuICAgICAgQXJyYXkuZnJvbSh0aGlzLnByb3ZpZGVycy52YWx1ZXMoKSkubWFwKChwcm92aWRlcikgPT5cclxuICAgICAgICBwcm92aWRlci5pbml0aWFsaXplKHRoaXMuYXV0b0xvZ2luKVxyXG4gICAgICApXHJcbiAgICApXHJcbiAgICAgIC50aGVuKCgpID0+IHtcclxuICAgICAgICBpZiAodGhpcy5hdXRvTG9naW4pIHtcclxuICAgICAgICAgIGNvbnN0IGxvZ2luU3RhdHVzUHJvbWlzZXMgPSBbXTtcclxuICAgICAgICAgIGxldCBsb2dnZWRJbiA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgIHRoaXMucHJvdmlkZXJzLmZvckVhY2goKHByb3ZpZGVyOiBMb2dpblByb3ZpZGVyLCBrZXk6IHN0cmluZykgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBwcm9taXNlID0gcHJvdmlkZXIuZ2V0TG9naW5TdGF0dXMoKTtcclxuICAgICAgICAgICAgbG9naW5TdGF0dXNQcm9taXNlcy5wdXNoKHByb21pc2UpO1xyXG4gICAgICAgICAgICBwcm9taXNlXHJcbiAgICAgICAgICAgICAgLnRoZW4oKHVzZXI6IFNvY2lhbFVzZXIpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0VXNlcih1c2VyLCBrZXkpO1xyXG4gICAgICAgICAgICAgICAgbG9nZ2VkSW4gPSB0cnVlO1xyXG4gICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgLmNhdGNoKGNvbnNvbGUuZGVidWcpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICBQcm9taXNlLmFsbChsb2dpblN0YXR1c1Byb21pc2VzKS5jYXRjaCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghbG9nZ2VkSW4pIHtcclxuICAgICAgICAgICAgICB0aGlzLl91c2VyID0gbnVsbDtcclxuICAgICAgICAgICAgICB0aGlzLl9hdXRoU3RhdGUubmV4dChudWxsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnByb3ZpZGVycy5mb3JFYWNoKChwcm92aWRlciwga2V5KSA9PiB7XHJcbiAgICAgICAgICBpZiAoaXNPYnNlcnZhYmxlKHByb3ZpZGVyLmNoYW5nZVVzZXIpKSB7XHJcbiAgICAgICAgICAgIHByb3ZpZGVyLmNoYW5nZVVzZXIuc3Vic2NyaWJlKCh1c2VyKSA9PiB7XHJcbiAgICAgICAgICAgICAgdGhpcy5fbmdab25lLnJ1bigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldFVzZXIodXNlciwga2V5KTtcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0pXHJcbiAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcclxuICAgICAgICBvbkVycm9yKGVycm9yKTtcclxuICAgICAgfSlcclxuICAgICAgLmZpbmFsbHkoKCkgPT4ge1xyXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX2luaXRTdGF0ZS5uZXh0KHRoaXMuaW5pdGlhbGl6ZWQpO1xyXG4gICAgICAgIHRoaXMuX2luaXRTdGF0ZS5jb21wbGV0ZSgpO1xyXG4gICAgICB9KTtcclxuICB9XHJcblxyXG4gIGFzeW5jIGdldEFjY2Vzc1Rva2VuKHByb3ZpZGVySWQ6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XHJcbiAgICBjb25zdCBwcm92aWRlck9iamVjdCA9IHRoaXMucHJvdmlkZXJzLmdldChwcm92aWRlcklkKTtcclxuICAgIGlmICghdGhpcy5pbml0aWFsaXplZCkge1xyXG4gICAgICB0aHJvdyBTb2NpYWxBdXRoU2VydmljZS5FUlJfTk9UX0lOSVRJQUxJWkVEO1xyXG4gICAgfSBlbHNlIGlmICghcHJvdmlkZXJPYmplY3QpIHtcclxuICAgICAgdGhyb3cgU29jaWFsQXV0aFNlcnZpY2UuRVJSX0xPR0lOX1BST1ZJREVSX05PVF9GT1VORDtcclxuICAgIH0gZWxzZSBpZiAoIShwcm92aWRlck9iamVjdCBpbnN0YW5jZW9mIEdvb2dsZUxvZ2luUHJvdmlkZXIpKSB7XHJcbiAgICAgIHRocm93IFNvY2lhbEF1dGhTZXJ2aWNlLkVSUl9OT1RfU1VQUE9SVEVEX0ZPUl9BQ0NFU1NfVE9LRU47XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGF3YWl0IHByb3ZpZGVyT2JqZWN0LmdldEFjY2Vzc1Rva2VuKCk7XHJcbiAgfVxyXG5cclxuICByZWZyZXNoQXV0aFRva2VuKHByb3ZpZGVySWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgaWYgKCF0aGlzLmluaXRpYWxpemVkKSB7XHJcbiAgICAgICAgcmVqZWN0KFNvY2lhbEF1dGhTZXJ2aWNlLkVSUl9OT1RfSU5JVElBTElaRUQpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IHByb3ZpZGVyT2JqZWN0ID0gdGhpcy5wcm92aWRlcnMuZ2V0KHByb3ZpZGVySWQpO1xyXG4gICAgICAgIGlmIChwcm92aWRlck9iamVjdCkge1xyXG4gICAgICAgICAgaWYgKHR5cGVvZiBwcm92aWRlck9iamVjdC5yZWZyZXNoVG9rZW4gIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgcmVqZWN0KFNvY2lhbEF1dGhTZXJ2aWNlLkVSUl9OT1RfU1VQUE9SVEVEX0ZPUl9SRUZSRVNIX1RPS0VOKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHByb3ZpZGVyT2JqZWN0XHJcbiAgICAgICAgICAgICAgLnJlZnJlc2hUb2tlbigpXHJcbiAgICAgICAgICAgICAgLnRoZW4oKHVzZXIpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0VXNlcih1c2VyLCBwcm92aWRlcklkKTtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcmVqZWN0KFNvY2lhbEF1dGhTZXJ2aWNlLkVSUl9MT0dJTl9QUk9WSURFUl9OT1RfRk9VTkQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICByZWZyZXNoQWNjZXNzVG9rZW4ocHJvdmlkZXJJZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZWQpIHtcclxuICAgICAgICByZWplY3QoU29jaWFsQXV0aFNlcnZpY2UuRVJSX05PVF9JTklUSUFMSVpFRCk7XHJcbiAgICAgIH0gZWxzZSBpZiAocHJvdmlkZXJJZCAhPT0gR29vZ2xlTG9naW5Qcm92aWRlci5QUk9WSURFUl9JRCkge1xyXG4gICAgICAgIHJlamVjdChTb2NpYWxBdXRoU2VydmljZS5FUlJfTk9UX1NVUFBPUlRFRF9GT1JfUkVGUkVTSF9UT0tFTik7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc3QgcHJvdmlkZXJPYmplY3QgPSB0aGlzLnByb3ZpZGVycy5nZXQocHJvdmlkZXJJZCk7XHJcbiAgICAgICAgaWYgKHByb3ZpZGVyT2JqZWN0IGluc3RhbmNlb2YgR29vZ2xlTG9naW5Qcm92aWRlcikge1xyXG4gICAgICAgICAgcHJvdmlkZXJPYmplY3QucmV2b2tlQWNjZXNzVG9rZW4oKS50aGVuKHJlc29sdmUpLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHJlamVjdChTb2NpYWxBdXRoU2VydmljZS5FUlJfTE9HSU5fUFJPVklERVJfTk9UX0ZPVU5EKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQSBtZXRob2QgdXNlZCB0byBzaWduIGluIGEgdXNlciB3aXRoIGEgc3BlY2lmaWMgYExvZ2luUHJvdmlkZXJgLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHByb3ZpZGVySWQgSWQgd2l0aCB3aGljaCB0aGUgYExvZ2luUHJvdmlkZXJgIGhhcyBiZWVuIHJlZ2lzdGVyZWQgd2l0aCB0aGUgc2VydmljZVxyXG4gICAqIEBwYXJhbSBzaWduSW5PcHRpb25zIE9wdGlvbmFsIGBMb2dpblByb3ZpZGVyYCBzcGVjaWZpYyBhcmd1bWVudHNcclxuICAgKiBAcmV0dXJucyBBIGBQcm9taXNlYCB0aGF0IHJlc29sdmVzIHRvIHRoZSBhdXRoZW50aWNhdGVkIHVzZXIgaW5mb3JtYXRpb25cclxuICAgKi9cclxuICBzaWduSW4ocHJvdmlkZXJJZDogc3RyaW5nLCBzaWduSW5PcHRpb25zPzogYW55KTogUHJvbWlzZTxTb2NpYWxVc2VyPiB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZWQpIHtcclxuICAgICAgICByZWplY3QoU29jaWFsQXV0aFNlcnZpY2UuRVJSX05PVF9JTklUSUFMSVpFRCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbGV0IHByb3ZpZGVyT2JqZWN0ID0gdGhpcy5wcm92aWRlcnMuZ2V0KHByb3ZpZGVySWQpO1xyXG4gICAgICAgIGlmIChwcm92aWRlck9iamVjdCkge1xyXG4gICAgICAgICAgcHJvdmlkZXJPYmplY3RcclxuICAgICAgICAgICAgLnNpZ25JbihzaWduSW5PcHRpb25zKVxyXG4gICAgICAgICAgICAudGhlbigodXNlcjogU29jaWFsVXNlcikgPT4ge1xyXG4gICAgICAgICAgICAgIHRoaXMuc2V0VXNlcih1c2VyLCBwcm92aWRlcklkKTtcclxuICAgICAgICAgICAgICByZXNvbHZlKHVzZXIpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xyXG4gICAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcmVqZWN0KFNvY2lhbEF1dGhTZXJ2aWNlLkVSUl9MT0dJTl9QUk9WSURFUl9OT1RfRk9VTkQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBIG1ldGhvZCB1c2VkIHRvIHNpZ24gb3V0IHRoZSBjdXJyZW50bHkgbG9nZ2VuIGluIHVzZXIuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gcmV2b2tlIE9wdGlvbmFsIHBhcmFtZXRlciB0byBzcGVjaWZ5IHdoZXRoZXIgYSBoYXJkIHNpZ24gb3V0IGlzIHRvIGJlIHBlcmZvcm1lZFxyXG4gICAqIEByZXR1cm5zIEEgYFByb21pc2VgIHRoYXQgcmVzb2x2ZXMgaWYgdGhlIG9wZXJhdGlvbiBpcyBzdWNjZXNzZnVsLCByZWplY3RzIG90aGVyd2lzZVxyXG4gICAqL1xyXG4gIHNpZ25PdXQocmV2b2tlOiBib29sZWFuID0gZmFsc2UpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgIGlmICghdGhpcy5pbml0aWFsaXplZCkge1xyXG4gICAgICAgIHJlamVjdChTb2NpYWxBdXRoU2VydmljZS5FUlJfTk9UX0lOSVRJQUxJWkVEKTtcclxuICAgICAgfSBlbHNlIGlmICghdGhpcy5fdXNlcikge1xyXG4gICAgICAgIHJlamVjdChTb2NpYWxBdXRoU2VydmljZS5FUlJfTk9UX0xPR0dFRF9JTik7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbGV0IHByb3ZpZGVySWQgPSB0aGlzLl91c2VyLnByb3ZpZGVyO1xyXG4gICAgICAgIGxldCBwcm92aWRlck9iamVjdCA9IHRoaXMucHJvdmlkZXJzLmdldChwcm92aWRlcklkKTtcclxuICAgICAgICBpZiAocHJvdmlkZXJPYmplY3QpIHtcclxuICAgICAgICAgIHByb3ZpZGVyT2JqZWN0XHJcbiAgICAgICAgICAgIC5zaWduT3V0KHJldm9rZSlcclxuICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgICB0aGlzLnNldFVzZXIobnVsbCk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XHJcbiAgICAgICAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICByZWplY3QoU29jaWFsQXV0aFNlcnZpY2UuRVJSX0xPR0lOX1BST1ZJREVSX05PVF9GT1VORCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgc2V0VXNlcih1c2VyOiBTb2NpYWxVc2VyIHwgbnVsbCwgaWQ/OiBzdHJpbmcpIHtcclxuICAgIGlmICh1c2VyICYmIGlkKSB1c2VyLnByb3ZpZGVyID0gaWQ7XHJcbiAgICB0aGlzLl91c2VyID0gdXNlcjtcclxuICAgIHRoaXMuX2F1dGhTdGF0ZS5uZXh0KHVzZXIpO1xyXG4gIH1cclxufVxyXG4iXX0=